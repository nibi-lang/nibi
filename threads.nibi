(use "io" "threads")

(fn busy [] [
  (loop (:= i 0) (< i 1000000000) (set i (+ i 1)) (nop))
  (<- 42)
])

(io::println "Starting...")

(:= tcell (threads::future (busy)))

#(io::println "tcell: " tcell ", is_ready: " (threads::future::ready tcell))


#(while (not (threads::future::ready tcell)) [
#  (io::println "waiting..")
#  (threads::future::wait tcell 1000000)
#])

#(io::println "Complete in " (threads::future::runtime tcell) "ms")

#(io::println "Got: " (threads::future::get tcell))


# The cell definition for tcell as an aberrant is being unloaded
# before the actual destructor is called. This makes it so it can't
# find the damn symbols when its being destructed and segs.

# If we ^ drop the cell as above before the thing is unloaded everything is
# fine, but if we wait it causes a bad

# We could create a "register" "deregister" method call for c++ modules
# that allow them to be signaled right before destruction. When this signal
# happens we could erase all aberrants generated and set their data value
# to a nullptr. Then regular cell destruction wouldn't invoke any 
# of the functions


(io::println "END")
