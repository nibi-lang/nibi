#pragma once

#include "libnibi/RLL/rll_wrapper.hpp"
#include "libnibi/cell.hpp"
#include "libnibi/environment.hpp"
#include "libnibi/error.hpp"
#include "libnibi/interfaces/instruction_processor_if.hpp"
#include "libnibi/modules.hpp"
#include "libnibi/source.hpp"

#include <stack>

#define PROFILE_INTERPRETER 0

namespace nibi {
//! \brief The runtime object that will be used to execute the code
//!        that is generated by the list builder
class interpreter_c final : public instruction_processor_if {
public:
  //! \brief A runtime exception
  class exception_c final : public std::exception {
  public:
    exception_c() = delete;

    //! \brief Construct a new exception
    //! \param message The message that will be printed
    exception_c(std::string message) : message_(message) {}

    //! \brief Construct a new exception
    //! \param message The message that will be printed
    //! \param source_location The location in the source code
    exception_c(std::string message, locator_ptr source_location)
        : message_(message), source_location_(source_location) {}
    char *what() { return const_cast<char *>(message_.c_str()); }
    locator_ptr get_source_location() const { return source_location_; }

  private:
    std::string message_;
    locator_ptr source_location_{nullptr};
  };

  //! \brief Construct a new interpreter object
  //! \param env The object that will used as the top level environment
  //! \param source_manager The source manager that will be used to track
  //!        imported files
  interpreter_c(env_c &env, source_manager_c &source_manager);

  //! \brief Destroy the interpreter object
  ~interpreter_c();

  //! \brief Indicate that we are in repl mode
  //! \note This will cause the interpreter to print the result of each
  //!       expression, and not exit on exception
  inline void indicate_repl() { repl_mode_ = true; };

  // From instruction_processor_if
  void instruction_ind(cell_ptr &cell) override;

  // From interpreter_c
  cell_ptr process_cell(cell_ptr instruction, env_c &env,
                        const bool process_data_cell = false);

  void set_yield_value(cell_ptr value) { yield_value_ = value; }

  bool is_yielding() { return yield_value_ != nullptr; }

  cell_ptr get_yield_value() { return yield_value_; }

  source_manager_c &get_source_manager() { return source_manager_; }

  void load_module(cell_ptr &module_name);

  cell_ptr get_last_result() { return last_result_; }

  env_c &get_env() { return interpreter_env; }

  void push_ctx() { ctxs_.push(ctx_s{}); }

  void pop_ctx(env_c &env);

  void defer_execution(cell_ptr ins) {
    if (ctxs_.empty()) {
      push_ctx();
    }
    ctxs_.top().deferred.push_back(ins);
  }

private:
  struct ctx_s {
    std::vector<cell_ptr> deferred;
  };

  // The last item that was processed
  cell_ptr last_result_{nullptr};

  // Module loader / manager
  modules_c modules_;

  // The environment that will be used to store and execute
  // the code that is generated by the list builder
  env_c &interpreter_env;

  // Source manager used to track imported files
  source_manager_c &source_manager_;

  // The yield value
  cell_ptr yield_value_{nullptr};

  // Handle a list cell
  cell_ptr handle_list_cell(cell_ptr &cell, env_c &env, bool process_data_cell);

  // Indicates if we are in repl mode
  bool repl_mode_{false};

  // Halt the interpreter with an error
  void halt_with_error(error_c error);

  std::stack<cell_ptr> call_stack_;

  std::stack<ctx_s> ctxs_;

#if PROFILE_INTERPRETER
  struct profile_info_s {
    int64_t calls{0};
    int64_t time{0};
  };
  std::unordered_map<std::string, profile_info_s> fn_call_data_;
#endif
};

} // namespace nibi
